<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>TERRA REACH: 50 LEVELS</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root { --ui-gold: #ffce00; --terra-green: #5da341; --ui-bg: rgba(44, 62, 80, 0.9); }
        body, html { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; background: #000; font-family: 'Press+Start+2P', cursive; user-select: none; }
        #game-container { width: 100vw; height: 100vh; }

        /* –ú–µ–Ω—é */
        #menu-overlay {
            position: fixed; inset: 0; background: #1a1a1a;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000; color: white;
        }
        .menu-card {
            background: #333; border: 4px solid #555; padding: 20px; text-align: center;
            box-shadow: 8px 8px 0 #000; max-width: 90%;
        }
        .title { color: var(--terra-green); font-size: 18px; text-shadow: 2px 2px #000; margin-bottom: 20px; }

        .previews { display: flex; gap: 20px; justify-content: center; margin: 20px 0; }
        .p-box { width: 70px; height: 100px; border: 3px solid #777; background: #111; position: relative; }
        .p-box canvas { width: 100%; height: 100%; image-rendering: pixelated; }
        .p-box.online { border-color: var(--ui-gold); box-shadow: 0 0 15px var(--ui-gold); }
        .label { position: absolute; bottom: -15px; font-size: 7px; width: 100%; left: 0; }

        .btn {
            background: #4a6e35; border: 4px solid #2d4522; color: #fff; padding: 12px;
            cursor: pointer; font-family: 'Press+Start+2P'; font-size: 10px; margin: 8px 0;
            width: 100%; display: block; box-shadow: 4px 4px 0 #1a2a14;
        }
        .btn:active { transform: translate(2px, 2px); box-shadow: none; }
        .btn.gold { background: #b08d00; border-color: #7a6200; box-shadow: 4px 4px 0 #4d3d00; }

        /* –°–æ—Å—Ç–æ—è–Ω–∏–µ */
        #status-text { font-size: 8px; color: #aaa; margin-top: 10px; }

        /* HUD */
        .hud { position: fixed; inset: 0; pointer-events: none; display: none; z-index: 100; }
        .grab-btn {
            position: absolute; bottom: 30px; width: 85px; height: 85px;
            border-radius: 50%; background: rgba(0,0,0,0.5); border: 4px solid #fff;
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
            color: #fff; font-size: 8px;
        }
        #btn-l { left: 40px; } #btn-r { right: 40px; }
        .grab-btn.active { background: var(--ui-gold); color: #000; transform: scale(1.1); }
        
        .lvl-tag { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 10px; background: rgba(0,0,0,0.5); padding: 10px; border: 2px solid #fff; }

        #rotate-msg { position: fixed; inset: 0; background: #000; z-index: 9999; display: none; flex-direction: column; align-items: center; justify-content: center; color: #fff; text-align: center; }
    </style>
</head>
<body>

    <div id="rotate-msg">
        <p>–ü–ï–†–ï–í–ï–†–ù–ò–¢–ï –¢–ï–õ–ï–§–û–ù<br>–î–õ–Ø –ò–ì–†–´</p>
        <span style="font-size: 40px;">üì±üîÑ</span>
    </div>

    <div id="menu-overlay">
        <div class="menu-card">
            <h1 class="title">TERRA REACH: 50 LVL</h1>
            
            <div class="previews">
                <div class="p-box online" id="p1-box">
                    <canvas id="c1"></canvas>
                    <div class="label">–í–´</div>
                </div>
                <div class="p-box" id="p2-box">
                    <canvas id="c2"></canvas>
                    <div class="label">–î–†–£–ì</div>
                </div>
            </div>

            <div id="btn-container">
                <button class="btn gold" id="btn-invite">1. –ö–û–ü–ò–†–û–í–ê–¢–¨ –°–°–´–õ–ö–£</button>
                <button class="btn" id="btn-start" style="opacity: 0.5;">2. –ñ–î–ï–ú –î–†–£–ì–ê...</button>
            </div>
            
            <p id="status-text">–í–ê–® ID: <span id="my-id">...</span></p>
        </div>
    </div>

    <div class="hud" id="hud">
        <div class="lvl-tag" id="lvl-display">LEVEL: 1</div>
        <div id="btn-l" class="grab-btn">–õ–ï–í–ê–Ø</div>
        <div id="btn-r" class="grab-btn">–ü–†–ê–í–ê–Ø</div>
    </div>

    <div id="game-container"></div>

<script>
/**
 * –°–ï–¢–ï–í–û–ô –ú–û–î–£–õ–¨
 */
const myId = Math.floor(1000 + Math.random() * 9000).toString();
let peer, conn, isConnected = false;

function initPeer() {
    peer = new Peer('TR-50LVL-' + myId);
    
    peer.on('open', () => {
        document.getElementById('my-id').innerText = myId;
        const hash = window.location.hash.replace('#', '');
        if (hash && hash.length === 4) {
            connectTo(hash);
        }
    });

    peer.on('connection', c => {
        conn = c;
        setupConnection();
    });
}

function connectTo(id) {
    conn = peer.connect('TR-50LVL-' + id);
    setupConnection();
}

function setupConnection() {
    conn.on('open', () => {
        isConnected = true;
        document.getElementById('p2-box').classList.add('online');
        document.getElementById('btn-start').innerText = "–ò–ì–†–ê–¢–¨ (FULLSCREEN)";
        document.getElementById('btn-start').style.opacity = "1";
        document.getElementById('status-text').innerText = "–°–û–ï–î–ò–ù–ï–ù–û!";
        document.getElementById('status-text').style.color = "#5da341";
        
        conn.on('data', data => {
            if (data.type === 'sync') window.gameScene?.onRemoteSync(data.state);
            if (data.type === 'lvl') window.gameScene?.loadLevel(data.lvl);
        });
    });
}

document.getElementById('btn-invite').onclick = () => {
    const url = window.location.origin + window.location.pathname + '#' + myId;
    navigator.clipboard.writeText(url);
    alert("–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞! –û—Ç–ø—Ä–∞–≤—å –µ—ë –¥—Ä—É–≥—É.");
};

document.getElementById('btn-start').onclick = async () => {
    if (!isConnected) return;
    if (document.documentElement.requestFullscreen) {
        await document.documentElement.requestFullscreen().catch(() => {});
        if (screen.orientation?.lock) await screen.orientation.lock('landscape').catch(() => {});
    }
    document.getElementById('menu-overlay').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    initGame();
};

/**
 * –ì–†–ê–§–ò–ö–ê –¢–ï–†–†–ê–†–ò–ò
 */
function createTextures(scene) {
    const draw = (key, w, h, colors) => {
        const canvas = scene.textures.createCanvas(key, w, h);
        const ctx = canvas.getContext();
        colors.forEach(c => {
            ctx.fillStyle = c.color;
            ctx.fillRect(c.x, c.y, c.w, c.h);
        });
        canvas.refresh();
    };

    // –ë–ª–æ–∫ –∑–µ–º–ª–∏
    draw('dirt', 32, 32, [
        {x:0, y:0, w:32, h:32, color:'#6d4c35'},
        {x:0, y:0, w:32, h:8, color:'#5da341'}, // —Ç—Ä–∞–≤–∞
        {x:5, y:12, w:4, h:4, color:'#5a3d2a'}
    ]);

    // –®–∏–ø—ã
    draw('spikes', 32, 32, [
        {x:0, y:20, w:32, h:12, color:'#444'},
        {x:8, y:0, w:4, h:20, color:'#999'},
        {x:20, y:0, w:4, h:20, color:'#999'}
    ]);
}

/**
 * –ò–ì–†–û–í–ê–Ø –°–¶–ï–ù–ê
 */
class MainScene extends Phaser.Scene {
    constructor() { super('MainScene'); }

    create() {
        window.gameScene = this;
        createTextures(this);
        this.matter.world.setBounds(0, -2000, 10000, 4000);
        this.level = 1;
        
        this.p1 = this.createPlayer(200, 400, 0x5da341, false);
        this.p2 = this.createPlayer(250, 400, 0x3498db, true);

        this.blocks = this.add.group();
        this.loadLevel(this.level);

        this.cameras.main.startFollow(this.p1.torso, true, 0.1, 0.1);
        this.cameras.main.setZoom(1.2);
        this.cameras.main.setBackgroundColor('#80a5ff');

        this.setupMobileControls();
    }

    createPlayer(x, y, color, isRemote) {
        const group = this.matter.world.nextGroup(true);
        const torso = this.matter.add.rectangle(x, y, 24, 34, { collisionFilter: { group }, chamfer: 5, friction: 0.8 });
        const head = this.matter.add.circle(x, y - 28, 11, { collisionFilter: { group } });
        const lHand = this.matter.add.circle(x - 20, y, 8, { collisionFilter: { group }, friction: 1 });
        const rHand = this.matter.add.circle(x + 20, y, 8, { collisionFilter: { group }, friction: 1 });

        this.matter.add.constraint(torso, head, 0, 0.8, { pointA: {x:0, y:-18}, pointB: {x:0, y:12} });
        this.matter.add.constraint(torso, lHand, 45, 0.1, { pointA: {x:-10, y:-10} });
        this.matter.add.constraint(torso, rHand, 45, 0.1, { pointA: {x:10, y:-10} });

        return { torso, head, lHand, rHand, color, grabL: false, grabR: false, isRemote, g: this.add.graphics() };
    }

    loadLevel(n) {
        this.level = n;
        document.getElementById('lvl-display').innerText = `LEVEL: ${n}`;
        this.blocks.clear(true, true);
        this.matter.world.localWorld.bodies.filter(b => b.isStatic && b.label !== 'bounds').forEach(b => this.matter.world.remove(b));

        // –ü–æ–ª
        this.addPlatform(200, 600, 600, 100);

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —É—Ä–æ–≤–Ω—è (50 —É—Ä–æ–≤–Ω–µ–π)
        const seed = n * 12345;
        for (let i = 1; i <= 5 + n; i++) {
            const px = 600 + (i * (180 + n * 5));
            const py = 600 - (Math.sin(seed + i) * 200);
            const width = Math.max(150 - (n * 2), 60);
            
            if (i % 4 === 0 && n > 5) {
                this.addSpikes(px, py - 30, width);
            } else {
                this.addPlatform(px, py, width, 40);
            }
        }

        // –§–∏–Ω–∏—à
        const fx = 800 + ((6 + n) * (180 + n * 5));
        const finish = this.add.star(fx, 400, 5, 20, 40, 0xffff00);
        this.matter.add.gameObject(finish, { isStatic: true, isSensor: true });
        finish.setOnCollide(pair => {
            if (pair.bodyA.gameObject === this.p1.torso.gameObject || pair.bodyB.gameObject === this.p1.torso.gameObject) {
                this.nextLevel();
            }
        });
        this.blocks.add(finish);
    }

    addPlatform(x, y, w, h) {
        const b = this.add.tileSprite(x, y, w, h, 'dirt');
        this.matter.add.gameObject(b, { isStatic: true });
        this.blocks.add(b);
    }

    addSpikes(x, y, w) {
        const b = this.add.tileSprite(x, y, w, 32, 'spikes');
        const body = this.matter.add.gameObject(b, { isStatic: true });
        body.setOnCollide(() => this.resetLevel());
        this.blocks.add(b);
    }

    nextLevel() {
        const next = this.level + 1;
        this.loadLevel(next);
        if (conn) conn.send({ type: 'lvl', lvl: next });
    }

    resetLevel() {
        this.p1.torso.position.x = 200;
        this.p1.torso.position.y = 400;
        this.p1.torso.velocity.x = 0;
        this.p1.torso.velocity.y = 0;
    }

    setupMobileControls() {
        const btnL = document.getElementById('btn-l');
        const btnR = document.getElementById('btn-r');
        
        btnL.onpointerdown = e => { e.preventDefault(); this.p1.grabL = !this.p1.grabL; btnL.classList.toggle('active'); };
        btnR.onpointerdown = e => { e.preventDefault(); this.p1.grabR = !this.p1.grabR; btnR.classList.toggle('active'); };
    }

    update() {
        this.handlePlayerInput(this.p1);
        this.processGrab(this.p1);
        this.processGrab(this.p2);
        this.drawPlayer(this.p1);
        this.drawPlayer(this.p2);
        this.sync();
    }

    handlePlayerInput(p) {
        this.input.pointers.forEach(ptr => {
            if (ptr.isDown && ptr.y < window.innerHeight - 120) {
                const hand = ptr.x < window.innerWidth / 2 ? p.lHand : p.rHand;
                const forceX = (ptr.x - ptr.downX) * 0.00018;
                const forceY = (ptr.y - ptr.downY) * 0.00018;
                this.matter.applyForce(hand, { x: forceX, y: forceY });
            }
        });
    }

    processGrab(p) {
        const sides = [{h: p.lHand, g: p.grabL, k: 'cL'}, {h: p.rHand, g: p.grabR, k: 'cR'}];
        sides.forEach(s => {
            if (s.g && !p[s.k]) {
                const bodies = this.matter.world.localWorld.bodies.filter(b => b !== s.h && b !== p.torso && b !== p.head);
                const hit = bodies.find(b => Phaser.Math.Distance.Between(s.h.position.x, s.h.position.y, b.position.x, b.position.y) < 25);
                if (hit) p[s.k] = this.matter.add.constraint(s.h, hit, 0, 1);
            } else if (!s.g && p[s.k]) {
                this.matter.world.removeConstraint(p[s.k]);
                p[s.k] = null;
            }
        });
    }

    drawPlayer(p) {
        const g = p.g; g.clear();
        const skin = p.isRemote ? 0xd1c4e9 : 0xffdbac;
        
        // –ì–æ–ª–æ–≤–∞
        g.fillStyle(skin); g.fillCircle(p.head.position.x, p.head.position.y, 11);
        g.fillStyle(0x000); g.fillRect(p.head.position.x+2, p.head.position.y-3, 2, 3);

        // –¢–µ–ª–æ
        g.fillStyle(p.color);
        g.save(); g.translateCanvas(p.torso.position.x, p.torso.position.y); g.rotate(p.torso.angle);
        g.fillRect(-12, -17, 24, 34); g.restore();

        // –†—É–∫–∏
        g.lineStyle(6, skin);
        g.lineBetween(p.torso.position.x, p.torso.position.y - 10, p.lHand.position.x, p.lHand.position.y);
        g.lineBetween(p.torso.position.x, p.torso.position.y - 10, p.rHand.position.x, p.rHand.position.y);
        
        g.fillStyle(p.grabL ? 0xffff00 : skin); g.fillCircle(p.lHand.position.x, p.lHand.position.y, 8);
        g.fillStyle(p.grabR ? 0xffff00 : skin); g.fillCircle(p.rHand.position.x, p.rHand.position.y, 8);
    }

    sync() {
        if (conn?.open) {
            conn.send({ type: 'sync', state: {
                tx: this.p1.torso.position.x, ty: this.p1.torso.position.y, ta: this.p1.torso.angle,
                hx: this.p1.head.position.x, hy: this.p1.head.position.y,
                lx: this.p1.lHand.position.x, ly: this.p1.lHand.position.y,
                rx: this.p1.rHand.position.x, ry: this.p1.rHand.position.y,
                gl: this.p1.grabL, gr: this.p1.grabR
            }});
        }
    }

    onRemoteSync(s) {
        const p = this.p2;
        this.matter.body.setPosition(p.torso, {x: s.tx, y: s.ty});
        this.matter.body.setAngle(p.torso, s.ta);
        this.matter.body.setPosition(p.head, {x: s.hx, y: s.hy});
        this.matter.body.setPosition(p.lHand, {x: s.lx, y: s.ly});
        this.matter.body.setPosition(p.rHand, {x: s.rx, y: s.ry});
        p.grabL = s.gl; p.grabR = s.gr;
    }
}

function initGame() {
    new Phaser.Game({
        type: Phaser.AUTO, parent: 'game-container',
        width: window.innerWidth, height: window.innerHeight,
        physics: { default: 'matter', matter: { gravity: { y: 1.2 }, debug: false } },
        scene: MainScene
    });
}

/**
 * –ü–†–û–í–ï–†–ö–ê –û–†–ò–ï–ù–¢–ê–¶–ò–ò
 */
function checkOrientation() {
    const msg = document.getElementById('rotate-msg');
    if (window.innerHeight > window.innerWidth) msg.style.display = 'flex';
    else msg.style.display = 'none';
}
window.addEventListener('resize', checkOrientation);
window.onload = () => {
    initPeer();
    checkOrientation();
    // –†–∏—Å—É–µ–º –ø—Ä–µ–≤—å—é –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
    const drawP = (id, color) => {
        const ctx = document.getElementById(id).getContext('2d');
        ctx.fillStyle = color; ctx.fillRect(15, 30, 40, 50);
        ctx.fillStyle = '#ffdbac'; ctx.beginPath(); ctx.arc(35, 20, 15, 0, 7); ctx.fill();
    };
    drawP('c1', '#5da341');
    drawP('c2', '#3498db');
};
</script>
</body>
</html>
